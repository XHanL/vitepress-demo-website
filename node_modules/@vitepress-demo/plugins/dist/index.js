import container from 'markdown-it-container';
import { resolve } from 'path';
import { readFileSync, existsSync } from 'fs';
import { parse, compileScript } from 'vue/compiler-sfc';
import { customAlphabet } from 'nanoid';

const demoMarkdownPlugin = (md) => {
    md.use(container, "demo", {
        render: (tokens, idx, options) => {
            if (tokens[idx].nesting == 1) {
                const props = tokens[idx].info
                    .trim()
                    .slice(4)
                    .trim()
                    .split("|")
                    .map((s) => s.trim());
                const title = md.render(props[0]) || "";
                const desc = md.render(props[1]) || "";
                const lang = props[2] || "";
                const code = decodeURIComponent(props[3]) || "";
                const highlight = options.highlight(code, lang, "");
                return md.render(`<p><Demo` +
                    ` title="${encodeURIComponent(title)}"` +
                    ` desc="${encodeURIComponent(desc)}"` +
                    ` lang="${encodeURIComponent(lang)}"` +
                    ` code="${encodeURIComponent(code)}"` +
                    ` highlight="${encodeURIComponent(highlight)}"` +
                    `>`);
            }
            return md.render(`</Demo></p>`);
        },
    });
};

const nanoid = customAlphabet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 8);
const MARKDOWN_ID_RE = /\.md$/;
const PREVIEW_ID_RE = /\.md\.Preview[A-Za-z0-9]{8}\.vue$/;
const CONTAINER_RE = /^(\:{3}|`{3,})([\s\S]*?)\n([\s\S]*?)\1(?:\n|$)/gm;
const FENCE_RE = /^(`{3,})[ \t]*([\s\S]*?)?\n([\s\S]*?)\1(?:\n|$)/gm;
const SCRIPT_RE = /<script\b[^>]*>([\s\S]*?)<\/script>/gi;
function demoVitePlugin() {
    const virtualModuleMap = {};
    return {
        name: "vite-plugin-vitepress-demo",
        enforce: "pre",
        resolveId(id) {
            if (PREVIEW_ID_RE.test(id)) {
                return id;
            }
        },
        load(id) {
            if (MARKDOWN_ID_RE.test(id)) {
                const { markdown, virtualModules } = parseMarkdown(id);
                Object.keys(virtualModules).forEach((k) => {
                    virtualModuleMap[`${id}.${k}.vue`] = virtualModules[k];
                });
                return markdown;
            }
            else if (PREVIEW_ID_RE.test(id)) {
                return virtualModuleMap[id];
            }
        },
    };
    function parseMarkdown(id) {
        const moduleMap = {};
        const virtualModules = {};
        const code = readFileSync(id, "utf8");
        const markdown = code
            .replace(CONTAINER_RE, (containerMatch, containerSymbol, containerInfo, containerContent) => {
            if (containerSymbol === ":::" &&
                containerInfo.trim().slice(0, 4) === "demo") {
                const demo = {};
                const infos = containerInfo
                    .trim()
                    .slice(4)
                    .trim()
                    .split("|")
                    .map((i) => i.trim());
                demo.title = infos.shift();
                demo.desc = infos.shift();
                const content = containerContent.trim();
                if (existsSync(content)) {
                    try {
                        demo.code = readFileSync(resolve(content), "utf-8");
                    }
                    catch (error) {
                        throw new Error(`Plugin: \n\nError: Unable to read file\n\nDetails: Unable to read content from "${id}".`);
                    }
                    const path = content.split("/").pop().split(".");
                    demo.lang = path.pop();
                    demo.name = path.pop();
                    moduleMap[demo.name] = resolve(content);
                    demo.preview = `\n<${demo.name}/>\n`;
                }
                else {
                    demo.preview = content.replace(FENCE_RE, (_fenceMatch, _fenceSymbol, fenceInfo, fenceContent) => {
                        demo.lang = fenceInfo.trim().split(/\s+/)[0].trim();
                        demo.code = fenceContent;
                        demo.name = `Preview${nanoid()}`;
                        virtualModules[demo.name] = demo.code;
                        return `\n<${demo.name}/>\n`;
                    });
                }
                return (`::: demo ${demo.title || ""}` +
                    `|${demo.desc || ""}` +
                    `|${demo.lang || ""}` +
                    `|${encodeURIComponent(demo.code || "")}` +
                    `\n${demo.preview}\n` +
                    `:::\n`);
            }
            return containerMatch;
        })
            .replace(SCRIPT_RE, (scriptMatch) => {
            const { descriptor, errors } = parse(scriptMatch);
            if (errors.length > 0) {
                throw errors;
            }
            const { imports } = compileScript(descriptor, {
                id: "null",
            });
            if (imports) {
                Object.keys(imports)
                    .filter((k) => !imports[k].isType && imports[k].isFromSetup)
                    .forEach((k) => {
                    moduleMap[imports[k].imported === "default" ? k : `{ ${k} }`] =
                        imports[k].source;
                });
            }
            return "";
        }) +
            `\n<script setup lang="ts">\n` +
            Object.keys(moduleMap)
                .map((k) => `import ${k} from "${moduleMap[k]}";\n`)
                .join("") +
            Object.keys(virtualModules)
                .map((k) => `import ${k} from "${id}.${k}.vue";\n`)
                .join("") +
            `</script>\n`;
        return { markdown: markdown, virtualModules: virtualModules };
    }
}

export { demoMarkdownPlugin, demoVitePlugin };
